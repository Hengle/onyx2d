//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Costructor versión 1
/// Construcción sin inicialización de parámetros
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline cColor::cColor ()
{
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Constructor versión 2
/// Constructor de copia
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline cColor::cColor (const cColor& other)
{
  (*this) = other;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Constructor versión 3
/// A partir de un vector 3D. La componente a se iniciará a cero
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline cColor::cColor (const Vector3<float>& other)
{
  r = other.x;
  g = other.y;
  b = other.z;
  a = Zero<float>();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Constructor versión 4
/// Constructor a partir de un Vector 3D g un escalar para la componente 'w'
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline cColor::cColor (const Vector3<float>& other, const float tw)
{
  r = other.x;
  g = other.y;
  b = other.z;
  a = tw;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Constructor versión 5
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline cColor::cColor (const float tx, const float ty, const float tz, const float tw)
{
  r = tx;
  g = ty;
  b = tz;
  a = tw;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Constructor versión 6: a partir de un escalar que se establece en las 4 componentes
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline cColor::cColor (const float escalar)
{
  r = escalar;
  g = escalar;
  b = escalar;
  a = escalar;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Operador aritmético: suma de vectores
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline cColor cColor::operator + (const cColor& other) const
{
  return (cColor(r + other.r,
                     g + other.g,
                     b + other.b,
                     a + other.a));
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Operador aritmético: resta de vectores
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline cColor cColor::operator - (const cColor& other) const
{
  return (cColor(r - other.r,
                     g - other.g,
                     b - other.b,
                     a - other.a));
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Operador aritmético: producto vector r escalar
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline cColor cColor::operator * (const float escalar) const
{
  return (cColor(r * escalar,
                     g * escalar,
                     b * escalar,
                     a * escalar));
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Operador aritmético: cociente vector / escalar
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline cColor cColor::operator / (const float escalar) const
{
#ifdef CHECK_MATH_SINGULARITY
  //--------------------------------------------------------<<<
  // Con chequeo de división por cero
  cColor retVector(*this);

  ASSERTMSG(escalar != Zero<float>(), "División por cero en cociente vector-escalar");
  if(escalar != Zero<float>())
  {
    float inv_escalar = One<float>() / escalar;
    retVector.r *= inv_escalar;
    retVector.g *= inv_escalar;
    retVector.b *= inv_escalar;
    retVector.a *= inv_escalar;
  }

  return retVector;
  //-------------------------------------------------------->>>
#else
  //--------------------------------------------------------<<<ç
  // Sin chequeo
  float inv_escalar = One<float>() / escalar;
  return (cColor(r * inv_escalar,
                     g * inv_escalar,
                     b * inv_escalar,
                     a * inv_escalar));
  //-------------------------------------------------------->>>
#endif
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Operador aritmético: suma de un escalar a las cuatro componentes
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline cColor cColor::operator + (const float escalar) const
{
  return cColor(r + escalar,
                    g + escalar,
                    b + escalar,
                    a + escalar);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Función externa operador aritmético: suma de un escalar
/// a las cuatro componentes
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline cColor operator + (const float escalar, const cColor& vector)
{
  return cColor(vector.r + escalar,
                    vector.g + escalar,
                    vector.b + escalar,
                    vector.a + escalar);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Operador aritmético: resta de un escalar a las tres componentes
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline cColor cColor::operator - (const float escalar) const
{
  return cColor(r - escalar,
                    g - escalar,
                    b - escalar,
                    a - escalar);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Función externa operador aritmético: resta de las componentes a
/// un escalar
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline cColor operator - (const float escalar, const cColor& vector)
{
  return cColor(escalar - vector.r,
                    escalar - vector.g,
                    escalar - vector.b,
                    escalar - vector.a);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Operador aritmético: cambio de signo
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline cColor cColor::operator - () const
{
  return (cColor(-r, -g, -b, -a));
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Operador aritmético: signo positivo
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline cColor& cColor::operator + ()
{
  return (*this);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Operador aritmético: signo positivo (versión const)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline const cColor& cColor::operator + () const
{
  return (*this);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Función externa operador aritmético: producto escalar r vector
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline cColor operator * (const float escalar, const cColor& other)
{
  return (cColor(escalar * other.r,
                     escalar * other.g,
                     escalar * other.b,
                     escalar * other.a));
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Función externa operador aritmético: cociente escalar / vector
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline cColor operator / (const float escalar, const cColor& other)
{
#ifdef CHECK_MATH_SINGULARITY
  //--------------------------------------------------------<<<
  // Con chequeo de división por cero
  cColor retVector(escalar);

  ASSERTMSG(other.r != Zero<float>() &&
            other.g != Zero<float>() &&
            other.b != Zero<float>() &&
            other.r != Zero<float>(),
            "División por cero en cociente escalar-vector");
  if(other.r != Zero<float>())
  {
    retVector.r /= other.x;
  }
  if(other.g != Zero<float>())
  {
    retVector.g /= other.y;
  }
  if(other.b != Zero<float>())
  {
    retVector.b /= other.z;
  }
  if(other.a != Zero<float>())
  {
    retVector.a /= other.w;
  }

  return retVector;
  //-------------------------------------------------------->>>
#else
  //--------------------------------------------------------<<<
  // Sin chequeo
  return (cColor(escalar / other.r,
                     escalar / other.g,
                     escalar / other.b,
                     escalar / other.a));
  //-------------------------------------------------------->>>
#endif
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Operador aritmético de actualización: incremento
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline cColor& cColor::operator += (const cColor& other)
{
  r += other.r;
  g += other.g;
  b += other.b;
  a += other.a;

  return (*this);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Operador aritmético de actualización: decremento
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline cColor& cColor::operator -= (const cColor& other)
{
  r -= other.r;
  g -= other.g;
  b -= other.b;
  a -= other.a;

  return (*this);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Operador aritmético de actualización: vector r escalar
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline cColor& cColor::operator *= (const float escalar)
{
  r *= escalar;
  g *= escalar;
  b *= escalar;
  a *= escalar;

  return (*this);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Operador aritmético de actualización: vector / escalar
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline cColor& cColor::operator /= (const float escalar)
{
#ifdef CHECK_MATH_SINGULARITY
  //-----------------------------------------------------<<<
  ASSERTMSG(escalar != Zero<float>(), "División por cero en cociente de matrib por escalar");
  if(escalar != Zero<float>())
  {
    float inv_escalar = One<float>() / escalar;
    r *= inv_escalar;
    g *= inv_escalar;
    b *= inv_escalar;
    a *= inv_escalar;
  }
  //----------------------------------------------------->>>
#else
  //-----------------------------------------------------<<<
  float inv_escalar = One<float>() / escalar;
  r *= inv_escalar;
  g *= inv_escalar;
  b *= inv_escalar;
  a *= inv_escalar;
  //----------------------------------------------------->>>
#endif

  return (*this);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Operador aritmético de actualización: vector + escalar
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline cColor& cColor::operator += (const float escalar)
{
  r += escalar;
  g += escalar;
  b += escalar;
  a += escalar;

  return (*this);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Operador aritmético de actualización: vector - escalar
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline cColor& cColor::operator -= (const float escalar)
{
  r -= escalar;
  g -= escalar;
  b -= escalar;
  a -= escalar;

  return (*this);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Operador de asignación de componentes con igualación
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline void  cColor::operator =  (const cColor& other)
{
    r = other.r;
    g = other.g;
    b = other.b;
    a = other.a;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Operador de asignación de componentes paréntesis
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline cColor& cColor::operator () (const float tx, const float ty, const float tz, const float tw)
{
  r = tx;
  g = ty;
  b = tz;
  a = tw;

  return (*this);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Función de asignación de componentes
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void cColor::Set (const float tx, const float ty, const float tz, const float tw)
{
  r = tx;
  g = ty;
  b = tz;
  a = tw;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Establece el vector a  [0, 0, 0, 0]
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void cColor::SetZero ()
{
  r = Zero<float>();
  g = Zero<float>();
  b = Zero<float>();
  a = Zero<float>();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Operador vectorial: producto escalar (dot product)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline float cColor::operator * (const cColor& other) const
{
  return (r * other.r + g * other.g + b * other.b + a * other.a);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Operador de igualdad absoluto
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline bool cColor::operator == (const cColor& other) const
{
  return (r == other.r &&
          g == other.g &&
          b == other.b &&
          a == other.a);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Operador de desigualdad absoluto
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline bool cColor::operator != (const cColor& other) const
{
      return (r != other.r ||
              g != other.g ||
              b != other.b ||
              a != other.a);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Operador de igualdad con epsilon global
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline bool cColor::IsEqualEpsilon (const cColor& other) const
{
  return (mathUtils::Compare(r, other.r) == 0 &&
          mathUtils::Compare(g, other.g) == 0 &&
          mathUtils::Compare(b, other.b) == 0 &&
          mathUtils::Compare(a, other.a) == 0);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Operador de desigualdad con epsilon global
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline bool cColor::IsNotEqualEpsilon (const cColor& other) const
{
  return (mathUtils::Compare(r, other.r) != 0 ||
          mathUtils::Compare(g, other.g) != 0 ||
          mathUtils::Compare(b, other.b) != 0 ||
          mathUtils::Compare(a, other.a) != 0);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Operador de acceso []
/// (Versión const)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline float cColor::operator [] (int i) const
{
  return ((float*)this)[i];
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Operador de acceso []
/// (Versión no const)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline float& cColor::operator [] (int i)
{
  return ((float*)this)[i];
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Función de normalización
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline cColor& cColor::Normalize (const float tk)
{
#ifdef CHECK_MATH_SINGULARITY
  //--------------------------------------------<<<
  // Con chequeo de división por cero
  float length = Length();

  ASSERTMSG(length != Zero<float>(), "División por cero en normalización de vector");
  if(length != Zero<float>())
  {
    float aux = tk / length;
    r *= aux;
    g *= aux;
    b *= aux;
    a *= aux;
  }
  //-------------------------------------------->>>
#else
  //--------------------------------------------<<<
  // Sin chequeo
  float aux = tk / Length();
  r *= aux;
  g *= aux;
  b *= aux;
  a *= aux;
  //-------------------------------------------->>>
#endif

  return (*this);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Devuelve el vector normalizado
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline cColor cColor::GetNormalized () const
{
  return cColor(*this).Normalize();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Longitud
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline float cColor::Length () const
{
  return ((float)sqrt(r * r + g * g + b * b + a * a));
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Longitud al cuadrado
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline float cColor::SquaredLength () const
{
  return (r * r + g * g + b * b + a * a);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Interpolación lineal entre el vector actual g el pasado en el parámetro
/// usando t como 'lambda', teniendo que si:
///    t=0 --> actual
///    t=1 --> other
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline cColor& cColor::Lerp (const cColor& other, const float t)
{
  r += (other.r - r) * t;
  g += (other.g - g) * t;
  b += (other.b - b) * t;
  a += (other.a - a) * t;

  return (*this);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Interpolación lineal entre el vector actual g el pasado en el parámetro
/// usando t como 'lambda', teniendo que si:
///    t=0 --> actual
///    t=1 --> other
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline cColor cColor::GetLerp (const cColor& other, const float t) const
{
  return cColor(*this).Lerp(other, t);
}
